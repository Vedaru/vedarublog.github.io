---
import type { MarkdownHeading } from "astro";

// import { siteConfig } from "../../config";

// import { url } from "../../utils/url-utils";

interface Props {
	class?: string;
	headings: MarkdownHeading[];
}

let { headings = [] } = Astro.props;

let minDepth = 10;
for (const heading of headings) {
	minDepth = Math.min(minDepth, heading.depth);
}

const className = Astro.props.class;
// const isPostsRoute =
// 	Astro.url.pathname.includes("/posts/") || headings.length > 0;

// const removeTailingHash = (text: string) => {
// 	let lastIndexOfHash = text.lastIndexOf("#");
// 	if (lastIndexOfHash !== text.length - 1) {
// 		return text;
// 	}
//
// 	return text.substring(0, lastIndexOfHash);
// };

// let heading1Count = 1;

// const maxLevel = siteConfig.toc.depth;
---
<table-of-contents class:list={[className, "group"]} id="toc">
    <!-- TOC内容将由JavaScript动态生成 -->
</table-of-contents>

<script>
class TableOfContents extends HTMLElement {
    tocEl: HTMLElement | null = null;
    visibleClass = "visible";
    observer: IntersectionObserver;
    anchorNavTarget: HTMLElement | null = null;
    headingIdxMap = new Map<string, number>();
    headings: HTMLElement[] = [];
    sections: HTMLElement[] = [];
    tocEntries: HTMLAnchorElement[] = [];
    active: boolean[] = [];
    activeIndicator: HTMLElement | null = null;

    constructor() {
        super();
        // 使用多个阈值以便更稳定地判断可见比例，并考虑导航栏高度偏移
        this.observer = new IntersectionObserver(
            this.markVisibleSection, { threshold: [0, 0.15, 0.5], rootMargin: '-80px 0px -40px 0px' }
        );
    };

    markVisibleSection = (entries: IntersectionObserverEntry[]) => {
        // 收集每个 entry 的 intersectionRatio 并选出最大的作为当前主导 section
        const ratioMap = new Map<number, number>(); // idx -> ratio

        entries.forEach((entry) => {
            const targetEl = entry.target as HTMLElement;
            // 优先使用 data 属性，兜底查找子元素带 id 的节点
            let id = targetEl.dataset.tocId || null;
            if (!id) {
                const descendantWithId = targetEl.querySelector('[id]') as HTMLElement | null;
                id = descendantWithId?.id ?? (targetEl.firstElementChild?.id ?? null);
            }

            const idx = id ? this.headingIdxMap.get(id) : undefined;
            const ratio = entry.intersectionRatio ?? (entry.isIntersecting ? 0.01 : 0);
            if (idx != undefined) {
                ratioMap.set(idx, Math.max(ratioMap.get(idx) ?? 0, ratio));
            }

            if (entry.isIntersecting && this.anchorNavTarget == targetEl.firstChild)
                this.anchorNavTarget = null;
        });

        // 将 active 数组全部置 false，然后只将 ratio 最大的项设为 true（更稳定）
        if (ratioMap.size > 0) {
            this.active.fill(false);
            let maxIdx = -1;
            let maxRatio = 0;
            ratioMap.forEach((r, i) => {
                if (r > maxRatio) {
                    maxRatio = r;
                    maxIdx = i;
                }
            });
            if (maxIdx >= 0) this.active[maxIdx] = true;
        } else if (!this.active.includes(true)) {
            // 如果没有任何 entry，使用回退策略
            this.fallback();
        }

        this.update();
    };

    toggleActiveHeading = () => {
        let i = this.active.length - 1;
        let min = this.active.length - 1, max = -1;
        while (i >= 0 && !this.active[i]) {
            if (this.tocEntries[i]) {
                this.tocEntries[i].classList.remove(this.visibleClass);
            }
            i--;
        }
        while (i >= 0 && this.active[i]) {
            if (this.tocEntries[i]) {
                this.tocEntries[i].classList.add(this.visibleClass);
                min = Math.min(min, i);
                max = Math.max(max, i);
            }
            i--;
        }
        while (i >= 0) {
            if (this.tocEntries[i]) {
                this.tocEntries[i].classList.remove(this.visibleClass);
            }
            i--;
        }
        if (min > max) {
            this.activeIndicator?.setAttribute("style", `opacity: 0`);
        } else {
            let parentOffset = this.tocEl?.getBoundingClientRect().top || 0;
            let scrollOffset = this.tocEl?.scrollTop || 0;
            const minEntry = this.tocEntries[min];
            const maxEntry = this.tocEntries[max];
            if (minEntry && maxEntry) {
                let top = minEntry.getBoundingClientRect().top - parentOffset + scrollOffset;
                let bottom = maxEntry.getBoundingClientRect().bottom - parentOffset + scrollOffset;
                this.activeIndicator?.setAttribute("style", `top: ${top}px; height: ${bottom - top}px`);
            }
        }
    };

    scrollToActiveHeading = () => {
        // If the TOC widget can accommodate both the topmost
        // and bottommost items, scroll to the topmost item. 
        // Otherwise, scroll to the bottommost one.

        if (this.anchorNavTarget || !this.tocEl) return;
        const activeHeading =
            document.querySelectorAll<HTMLDivElement>(`#toc .${this.visibleClass}`);
        if (!activeHeading.length) return;

        const topmost = activeHeading[0];
        const bottommost = activeHeading[activeHeading.length - 1];
        const tocHeight = this.tocEl.clientHeight;

        let top: number;
        if (bottommost.getBoundingClientRect().bottom -
            topmost.getBoundingClientRect().top < 0.9 * tocHeight)
            top = topmost.offsetTop - 32;
        else
            top = bottommost.offsetTop - tocHeight * 0.8;

        this.tocEl.scrollTo({
            top,
            left: 0,
            behavior: "smooth",
        });
    };

    update = () => {
        requestAnimationFrame(() => {
            this.toggleActiveHeading();
            // requestAnimationFrame(() => {
            this.scrollToActiveHeading();
            // });
        });
    };

    fallback = () => {
        if (!this.sections.length) return;

        for (let i = 0; i < this.sections.length; i++) {
            let offsetTop = this.sections[i].getBoundingClientRect().top;
            let offsetBottom = this.sections[i].getBoundingClientRect().bottom;

            if (this.isInRange(offsetTop, 0, window.innerHeight)
                || this.isInRange(offsetBottom, 0, window.innerHeight)
                || (offsetTop < 0 && offsetBottom > window.innerHeight)) {                    
                this.markActiveHeading(i);
            }
            else if (offsetTop > window.innerHeight) break;
        }
    };

    markActiveHeading = (idx: number)=> {
        this.active[idx] = true;
    };

    handleAnchorClick = (event: Event) => {
        const anchor = event
            .composedPath()
            .find((element) => element instanceof HTMLAnchorElement);

        if (anchor) {
            event.preventDefault(); // 阻止默认的锚点跳转
            
            const id = decodeURIComponent(anchor.hash?.substring(1));
            const targetElement = document.getElementById(id);
            
            if (targetElement) {
                // 计算目标位置，与移动端保持一致
                const navbarHeight = 80; // 导航栏高度
                const targetTop = targetElement.getBoundingClientRect().top + window.scrollY - navbarHeight;
                
                // 使用与移动端相同的滚动方式
                window.scrollTo({
                    top: targetTop,
                    behavior: "smooth"
                });
            }
            
            const idx = this.headingIdxMap.get(id);
            if (idx !== undefined) {
                this.anchorNavTarget = this.headings[idx];
            } else {
                this.anchorNavTarget = null;
            }
        }
    };

    isInRange(value: number, min: number, max: number) {
        return min < value && value < max;
    };

    connectedCallback() {
        // 优先监听动画结束，兜底定时初始化，确保二次刷新也能正常显示 TOC
        const element = document.querySelector('.custom-md') || document.querySelector('.prose') || document.querySelector('.markdown-content');
        let initialized = false;
        const tryInit = () => {
            if (!initialized) {
                initialized = true;
                this.init();
            }
        };
        if (element) {
            element.addEventListener('animationend', tryInit, { once: true });
            // 兜底：无论动画是否触发，300ms后强制初始化一次
            setTimeout(tryInit, 300);
        } else {
            // 没有动画元素，直接初始化，兜底再延迟一次
            tryInit();
            setTimeout(tryInit, 300);
        }
    };

    init() {
        // 重新生成TOC内容
        this.regenerateTOC();

        this.tocEl = this;

        this.tocEl.addEventListener("click", this.handleAnchorClick, {
            capture: true,
        });

        this.activeIndicator = document.getElementById("active-indicator");

        this.tocEntries = Array.from(
            this.querySelectorAll<HTMLAnchorElement>("a[href^='#']")
        );

        if (this.tocEntries.length === 0) return;

        this.sections = new Array(this.tocEntries.length);
        this.headings = new Array(this.tocEntries.length);
        const isDiary = window.location.pathname.includes('/diary') || document.querySelector('.moments-timeline') !== null;
        for (let i = 0; i < this.tocEntries.length; i++) {
            const id = decodeURIComponent(this.tocEntries[i].hash?.substring(1));
            const heading = document.getElementById(id);
            let section: HTMLElement | null = null;

            if (isDiary) {
                // 在日记页面，优先选择与该 id 匹配且非 H1-H6 的元素（比如第一个 moment item），
                // 这样 IntersectionObserver 能观察到实际滚动区域；找不到则回退到 heading 的父元素
                const candidates = Array.from(document.querySelectorAll(`#${CSS.escape(id)}`)) as HTMLElement[];
                section = candidates.find(el => !/^H[1-6]$/.test(el.tagName)) || heading?.parentElement || null;
            } else {
                section = heading?.parentElement || null;
            }

            if (heading instanceof HTMLElement && section instanceof HTMLElement) {
                this.headings[i] = heading;
                this.sections[i] = section;
                this.headingIdxMap.set(id, i);
                // 为了更可靠地从 entry.target 读取 id，保存到 data 属性
                try { section.dataset.tocId = id; } catch (e) { /* ignore */ }
            }
        }
        this.active = new Array(this.tocEntries.length).fill(false);

        this.sections.forEach((section) =>
            this.observer.observe(section)
        );

        this.fallback();
        this.update();
    };

    regenerateTOC(retryCount = 0) {
        // 检查是否为文章页面
        const isPostPage = window.location.pathname.includes('/posts/') || 
                          document.querySelector('.custom-md, .markdown-content') !== null ||
                          window.location.pathname.includes('/diary') ||
                          document.querySelector('.moments-timeline') !== null;
        if (!isPostPage) {
            // 如果不是文章或日记页面，隐藏TOC
            this.innerHTML = '';
            delete this.dataset.loaded;
            return;
        }
        // 从当前页面重新获取标题
        const headings = Array.from(document.querySelectorAll('h1, h2, h3, h4, h5, h6'))
            .filter(h => h.id)
            .map(h => ({
                depth: parseInt(h.tagName.substring(1)),
                slug: h.id,
                text: (h.textContent || '').replace(/#+\s*$/, '')
            }));

        // 如果是日记页面，按年-月升序排列（从早到晚）以便 TOC 从上到下显示早到晚
        const isDiaryPage = window.location.pathname.includes('/diary') || document.querySelector('.moments-timeline') !== null;
        if (isDiaryPage) {
            const ymRegex = /^year-(\d{4})(?:-month-(\d{2}))?$/;
            headings.sort((a, b) => {
                const am = a.slug.match(ymRegex);
                const bm = b.slug.match(ymRegex);
                if (am && bm) {
                    const ay = parseInt(am[1], 10);
                    const amonthRaw = am[2];
                    const amonth = amonthRaw ? parseInt(amonthRaw, 10) : undefined;
                    const by = parseInt(bm[1], 10);
                    const bmonthRaw = bm[2];
                    const bmonth = bmonthRaw ? parseInt(bmonthRaw, 10) : undefined;

                    // 如果一个是 year、另一个是 month，保证 year 在 month 之前（即年级标题排在该年月份的上方）
                    if (amonth === undefined && bmonth !== undefined) {
                        // 同年则 year 在前；不同年则按年降序
                        if (by !== ay) return by - ay;
                        return -1;
                    }
                    if (amonth !== undefined && bmonth === undefined) {
                        if (by !== ay) return by - ay;
                        return 1;
                    }

                    // 两者均为 year 或均为 month：按 年+月 降序
                    const aKey = ay * 100 + (amonth ?? 0);
                    const bKey = by * 100 + (bmonth ?? 0);
                    return bKey - aKey; // 降序
                } else if (am && !bm) {
                    // a 匹配，b 不匹配 → 将匹配项靠前
                    return -1;
                } else if (!am && bm) {
                    return 1;
                }
                return 0;
            });
        }
        // 如果没有标题，延迟重试最多3次
        if (headings.length === 0 && retryCount < 3) {
            setTimeout(() => this.regenerateTOC(retryCount + 1), 120);
            return;
        }
        if (headings.length === 0) {
            this.innerHTML = '';
            delete this.dataset.loaded;
            return;
        }
        // 重新生成TOC HTML
        const minDepth = Math.min(...headings.map(h => h.depth));
        // 获取配置信息
        const siteConfig = (window as any).siteConfig || {};
        const maxLevel = siteConfig.toc?.depth || 3;
        const useJapaneseBadge = siteConfig.toc?.useJapaneseBadge || false;
        
        // 添加调试信息
        console.log('TOC Config in regenerateTOC:', { siteConfig: siteConfig.toc, maxLevel, useJapaneseBadge });
        
        // 日语片假名字符集
        const japaneseKatakana = [
            "ア", "イ", "ウ", "エ", "オ",
            "カ", "キ", "ク", "ケ", "コ",
            "サ", "シ", "ス", "セ", "ソ",
            "タ", "チ", "ツ", "テ", "ト",
            "ナ", "ニ", "ヌ", "ネ", "ノ",
            "ハ", "ヒ", "フ", "ヘ", "ホ",
            "マ", "ミ", "ム", "メ", "モ",
            "ヤ", "ユ", "ヨ",
            "ラ", "リ", "ル", "レ", "ロ",
            "ワ", "ヲ", "ン"
        ];
        
        let heading1Count = 1;
        const tocHTML = headings
            .filter(heading => heading.depth < minDepth + maxLevel)
            .map(heading => {
                const depthClass = heading.depth === minDepth ? '' : 
                    heading.depth === minDepth + 1 ? 'ml-4' : 'ml-8';
                
                let badgeContent = '';
                if (heading.depth === minDepth) {
                    if (useJapaneseBadge && heading1Count - 1 < japaneseKatakana.length) {
                        badgeContent = japaneseKatakana[heading1Count - 1];
                    } else {
                        badgeContent = heading1Count.toString();
                    }
                    heading1Count++;
                } else if (heading.depth === minDepth + 1) {
                    badgeContent = '<div class="transition w-2 h-2 rounded-[0.1875rem] bg-[var(--toc-badge-bg)]"></div>';
                } else {
                    badgeContent = '<div class="transition w-1.5 h-1.5 rounded-sm bg-black/5 dark:bg-white/10"></div>';
                }
                
                return `<a href="#${heading.slug}" class="px-2 flex gap-2 relative transition w-full min-h-9 rounded-xl hover:bg-[var(--toc-btn-hover)] active:bg-[var(--toc-btn-active)] py-2">
                    <div class="transition w-5 h-5 shrink-0 rounded-lg text-xs flex items-center justify-center font-bold ${depthClass} ${heading.depth === minDepth ? 'bg-[var(--toc-badge-bg)] text-[var(--btn-content)]' : ''}">
                        ${badgeContent}
                    </div>
                    <div class="transition text-sm ${heading.depth <= minDepth + 1 ? 'text-50' : 'text-30'}">${heading.text}</div>
                </a>`;
            }).join('');
        this.innerHTML = tocHTML + '<div id="active-indicator" style="opacity: 0" class="-z-10 absolute bg-[var(--toc-btn-hover)] left-0 right-0 rounded-xl transition-all group-hover:bg-transparent border-2 border-[var(--toc-btn-hover)] group-hover:border-[var(--toc-btn-active)] border-dashed"></div>';
        this.dataset.loaded = "true";
    }

    disconnectedCallback() {
        this.sections.forEach((section) =>
            this.observer.unobserve(section)
        );
        this.observer.disconnect();
        this.tocEl?.removeEventListener("click", this.handleAnchorClick);
    };
}

if (!customElements.get("table-of-contents")) {
    customElements.define("table-of-contents", TableOfContents);
}
</script>

<style>
  table-of-contents#toc {
      max-height: 100%;
      overflow: auto;
      position: relative;
      scroll-behavior: smooth;
      display: block;
  }

  table-of-contents#toc::-webkit-scrollbar {
      display: none;
  }
</style>
