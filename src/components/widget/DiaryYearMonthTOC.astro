---
/**
 * 日记年月目录组件
 * 显示日记的年份和月份导航
 * 样式和逻辑与文章TOC保持一致
 */

interface Props {
	groupedMoments: any[];
}

const { groupedMoments } = Astro.props;
---

<div class="diary-toc-container">
	<nav class="diary-toc group" id="diary-toc-nav">
		{groupedMoments.map(([year, months]) => {
			const totalCount = months.reduce((acc, [, arr]) => acc + arr.length, 0);
			return (
				<div class="toc-year-group">
					<a 
						href={`#year-${year}`}
						class="toc-year-link px-2 flex gap-2 relative transition w-full min-h-9 rounded-xl hover:bg-[var(--toc-btn-hover)] active:bg-[var(--toc-btn-active)] py-2"
					>
						<div class="transition w-5 h-5 shrink-0 rounded-lg text-xs flex items-center justify-center font-bold bg-[var(--toc-badge-bg)] text-[var(--btn-content)]">
							{year.toString().slice(-2)}
						</div>
						<div class="transition text-sm text-50 flex-1">{year}</div>
						<span class="text-xs text-30">({totalCount})</span>
					</a>
					<div class="toc-months">
						{months.map(([month, items]) => (
							<a
								href={`#month-${year}-${month}`}
								class="toc-month-link px-2 flex gap-2 relative transition w-full min-h-9 rounded-xl hover:bg-[var(--toc-btn-hover)] active:bg-[var(--toc-btn-active)] py-2"
							>
								<div class="transition w-5 h-5 shrink-0 rounded-lg text-xs flex items-center justify-center font-bold ml-4">
									<div class="transition w-2 h-2 rounded-[0.1875rem] bg-[var(--toc-badge-bg)]"></div>
								</div>
								<div class="transition text-sm text-50 flex-1">{month}月</div>
								<span class="text-xs text-30">({items.length})</span>
							</a>
						))}
					</div>
				</div>
			);
		})}
		<div id="diary-active-indicator" class="-z-10 absolute bg-[var(--toc-btn-hover)] left-0 right-0 rounded-xl transition-all group-hover:bg-transparent border-2 border-[var(--toc-btn-hover)] group-hover:border-[var(--toc-btn-active)] border-dashed" style="opacity: 0;"></div>
	</nav>
</div>

<style>
	.diary-toc-container {
		max-height: 100%;
		overflow: auto;
		scroll-behavior: smooth;
	}

	.diary-toc-container::-webkit-scrollbar {
		display: none;
	}

	.diary-toc {
		position: relative;
		display: block;
	}

	.toc-year-group {
		margin-bottom: 0;
	}

	/* 活动状态样式 - 与文章TOC一致，使用visible类 */
	.toc-year-link.visible,
	.toc-month-link.visible {
		/* 不需要额外的背景色，由active-indicator提供 */
	}
</style>

<script>
	class DiaryTOC {
		tocEl: HTMLElement | null = null;
		visibleClass = "visible";
		observer: IntersectionObserver;
		activeIndicator: HTMLElement | null = null;
		linkIdxMap = new Map<string, number>();
		sections: HTMLElement[] = [];
		tocLinks: HTMLAnchorElement[] = [];
		active: boolean[] = [];

		constructor() {
			this.observer = new IntersectionObserver(
				this.markVisibleSection,
				{ threshold: 0 }
			);
		}

		markVisibleSection = (entries: IntersectionObserverEntry[]) => {
			entries.forEach((entry) => {
				const id = entry.target.id;
				const idx = id ? this.linkIdxMap.get(id) : undefined;
				if (idx !== undefined) {
					this.active[idx] = entry.isIntersecting;
				}
			});

			if (!this.active.includes(true)) {
				this.fallback();
			}
			this.update();
		};

		toggleActiveHeading = () => {
			let i = this.active.length - 1;
			let min = this.active.length - 1, max = -1;
			
			// 从后向前遍历，移除不活跃的
			while (i >= 0 && !this.active[i]) {
				this.tocLinks[i]?.classList.remove(this.visibleClass);
				i--;
			}
			
			// 添加活跃的
			while (i >= 0 && this.active[i]) {
				this.tocLinks[i]?.classList.add(this.visibleClass);
				min = Math.min(min, i);
				max = Math.max(max, i);
				i--;
			}
			
			// 移除前面的
			while (i >= 0) {
				this.tocLinks[i]?.classList.remove(this.visibleClass);
				i--;
			}

			// 更新活动指示器
			if (min > max || !this.activeIndicator) {
				this.activeIndicator?.setAttribute("style", "opacity: 0");
			} else {
				const parentOffset = this.tocEl?.getBoundingClientRect().top || 0;
				const scrollOffset = this.tocEl?.scrollTop || 0;
				const top = this.tocLinks[min].getBoundingClientRect().top - parentOffset + scrollOffset;
				const bottom = this.tocLinks[max].getBoundingClientRect().bottom - parentOffset + scrollOffset;
				this.activeIndicator?.setAttribute("style", `top: ${top}px; height: ${bottom - top}px; opacity: 1;`);
			}
		};

		scrollToActiveHeading = () => {
			if (!this.tocEl) return;
			const activeHeading = this.tocEl.querySelectorAll<HTMLElement>(`.${this.visibleClass}`);
			if (!activeHeading.length) return;

			const topmost = activeHeading[0];
			const bottommost = activeHeading[activeHeading.length - 1];
			const tocHeight = this.tocEl.clientHeight;

			let top: number;
			if (bottommost.getBoundingClientRect().bottom - topmost.getBoundingClientRect().top < 0.9 * tocHeight) {
				top = topmost.offsetTop - 32;
			} else {
				top = bottommost.offsetTop - tocHeight * 0.8;
			}

			this.tocEl.scrollTo({
				top,
				left: 0,
				behavior: "smooth",
			});
		};

		update = () => {
			requestAnimationFrame(() => {
				this.toggleActiveHeading();
				this.scrollToActiveHeading();
			});
		};

		fallback = () => {
			if (!this.sections.length) return;

			for (let i = 0; i < this.sections.length; i++) {
				const offsetTop = this.sections[i].getBoundingClientRect().top;
				const offsetBottom = this.sections[i].getBoundingClientRect().bottom;

				if (this.isInRange(offsetTop, 0, window.innerHeight) ||
					this.isInRange(offsetBottom, 0, window.innerHeight) ||
					(offsetTop < 0 && offsetBottom > window.innerHeight)) {
					this.active[i] = true;
				} else if (offsetTop > window.innerHeight) {
					break;
				}
			}
		};

		handleAnchorClick = (event: Event) => {
			const anchor = event.composedPath().find((element) => element instanceof HTMLAnchorElement) as HTMLAnchorElement;

			if (anchor) {
				event.preventDefault();
				
				const id = decodeURIComponent(anchor.hash?.substring(1));
				const targetElement = document.getElementById(id);
				
				if (targetElement) {
					const navbarHeight = 80;
					const targetTop = targetElement.getBoundingClientRect().top + window.pageYOffset - navbarHeight;
					
					window.scrollTo({
						top: targetTop,
						behavior: "smooth"
					});
				}
			}
		};

		isInRange(value: number, min: number, max: number) {
			return min < value && value < max;
		}

		init() {
			const container = document.querySelector('.diary-toc-container');
			this.tocEl = document.querySelector('.diary-toc');
			if (!this.tocEl || !container) return;

			container.addEventListener("click", this.handleAnchorClick, { capture: true });

			this.activeIndicator = document.getElementById("diary-active-indicator");

			this.tocLinks = Array.from(
				document.querySelectorAll<HTMLAnchorElement>(".toc-year-link, .toc-month-link")
			);

			if (this.tocLinks.length === 0) return;

			this.sections = [];
			this.tocLinks.forEach((link, i) => {
				const id = decodeURIComponent(link.hash?.substring(1));
				const section = document.getElementById(id);
				if (section instanceof HTMLElement) {
					this.sections.push(section);
					this.linkIdxMap.set(id, i);
				}
			});

			this.active = new Array(this.tocLinks.length).fill(false);

			this.sections.forEach((section) => this.observer.observe(section));

			this.fallback();
			this.update();
		}

		destroy() {
			this.sections.forEach((section) => this.observer.unobserve(section));
			this.observer.disconnect();
			const container = document.querySelector('.diary-toc-container');
			container?.removeEventListener("click", this.handleAnchorClick);
		}
	}

	let diaryTOCInstance: DiaryTOC | null = null;

	function initDiaryTOC() {
		// 检查是否在日记页面
		const isDiaryPage = window.location.pathname.includes('/diary');
		if (!isDiaryPage) return;

		// 清理旧实例
		if (diaryTOCInstance) {
			diaryTOCInstance.destroy();
		}

		// 创建新实例
		diaryTOCInstance = new DiaryTOC();
		diaryTOCInstance.init();
	}

	// 页面加载完成后初始化
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initDiaryTOC);
	} else {
		setTimeout(initDiaryTOC, 100);
	}

	// Swup页面切换时处理
	document.addEventListener('swup:content:replace', () => {
		const isDiaryPage = window.location.pathname.includes('/diary');
		const diaryTocWrapper = document.getElementById('diary-toc-wrapper');
		
		if (diaryTocWrapper) {
			if (isDiaryPage) {
				diaryTocWrapper.classList.remove('hidden');
				diaryTocWrapper.classList.add('lg:block');
				// 使用 requestAnimationFrame 确保 DOM 渲染完成后再初始化
				requestAnimationFrame(() => {
					requestAnimationFrame(() => {
						initDiaryTOC();
					});
				});
			} else {
				diaryTocWrapper.classList.add('hidden');
				diaryTocWrapper.classList.remove('lg:block');
				// 清理实例
				if (diaryTOCInstance) {
					diaryTOCInstance.destroy();
					diaryTOCInstance = null;
				}
			}
		}
	});

	// 监听 swup:page:view 事件（页面内容完全加载后）
	document.addEventListener('swup:page:view', () => {
		const isDiaryPage = window.location.pathname.includes('/diary');
		if (isDiaryPage) {
			// 确保 TOC 被初始化
			const tocNav = document.getElementById('diary-toc-nav');
			if (tocNav && (!diaryTOCInstance || diaryTOCInstance.tocLinks.length === 0)) {
				initDiaryTOC();
			}
		}
	});
</script>
