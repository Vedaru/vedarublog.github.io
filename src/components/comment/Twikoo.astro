---
import { commentConfig } from "@/config";

interface Props {
	path: string;
}

const config = {
	...commentConfig.twikoo,
	el: "#tcomment",
	path: Astro.props.path,
};
---

<div id="tcomment"></div>
<div id="tcomment-placeholder" style="text-align:center;margin:1rem 0;">
  <button id="load-twikoo-btn" class="twikoo-load-btn">加载评论</button>
</div>
<script is:inline>
  (function() {
    // Lazy loader: load scroll-protection and Twikoo when user requests or when comments are near viewport
    function loadTwikooScript() {
      if (window.__twikooScriptLoading || window.__twikooScriptLoaded) return window.__twikooScriptLoaded ? Promise.resolve() : window.__twikooScriptLoading;
      window.__twikooScriptLoading = new Promise((resolve, reject) => {
        const sp = document.createElement('script');
        // Use absolute public paths to avoid relying on build-time env in client runtime
        sp.src = '/scroll-protection.js';
        sp.defer = true;
        sp.onload = () => {
          const s = document.createElement('script');
          s.src = '/assets/js/twikoo.all.min.js';
          s.defer = true;
          s.onload = () => {
            window.__twikooScriptLoaded = true;
            resolve();
          };
          s.onerror = reject;
          document.head.appendChild(s);
        };
        sp.onerror = reject;
        document.head.appendChild(sp);
      });
      return window.__twikooScriptLoading;
    }
    document.addEventListener('click', function(e){
      if(e.target && e.target.id === 'load-twikoo-btn'){
        const btn = e.target;
        btn.disabled = true;
        const original = btn.textContent;
        btn.textContent = '加载中...';
        loadTwikooScript().then(() => {
          if (window.initTwikoo) {
            initTwikoo();
          }
          try {
            btn.remove();
            document.getElementById('tcomment-placeholder')?.remove();
          } catch (e) {
            // ignore
          }
        }).catch((err) => {
          console.error(err);
          btn.disabled = false;
          btn.textContent = '加载失败，重试';
          setTimeout(() => {
            btn.textContent = original;
          }, 3000);
        });
      }
    }, {capture:true});
    try {
      const obs = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const ph = document.getElementById('tcomment-placeholder');
            const btn = ph && ph.querySelector && ph.querySelector('#load-twikoo-btn');
            if (btn) { btn.disabled = true; btn.textContent = '加载中...'; }
            loadTwikooScript().then(() => {
              if (window.initTwikoo) {
                initTwikoo();
              }
              try {
                ph && ph.remove();
              } catch (e) {
                // ignore
              }
            }).catch(() => {
              if (btn) {
                btn.disabled = false;
                btn.textContent = '加载评论';
              }
            });
            obs.disconnect();
          }
        });
      }, { rootMargin: '200px' });
      obs.observe(document.getElementById('tcomment'));
    } catch (e) { /* ignore */ }
  })();
</script>
<script is:inline define:vars={{ config }}>
  // 获取当前页面路径
  function getCurrentPath() {
    const pathname = window.location.pathname;
    return pathname.endsWith('/') && pathname.length > 1 ? pathname.slice(0, -1) : pathname;
  }
  
  // 动态创建配置对象
  function createTwikooConfig() {
    return {
      ...config,
      path: getCurrentPath(),
      el: '#tcomment',
      // 确保使用站点配置的 SHOW_IMAGE（若未设置则默认 'false'），以便集中管理
      SHOW_IMAGE: config.SHOW_IMAGE || 'false'
    };
  }
  
  // 强制禁用图片上传 UI 与粘贴（运行时防御，以防配置或第三方脚本覆盖）
  function sanitizeCommentImages() {
    try {
      const commentEl = document.getElementById('tcomment');
      if (!commentEl) return;
      commentEl.querySelectorAll('img').forEach(img => {
        try {
          img.loading = 'lazy';
          img.decoding = 'async';
          img.style.maxWidth = '100%';
          img.style.height = 'auto';
          img.classList.add('tk-img-processed');
        } catch (e) {}
      });
    } catch (e) {
      // ignore
    }
  }

  function disableImageControls() {
    try {
      // 防止重复绑定（多次调用时安全）
      if (!window.__twikooDisableImage) {
        window.__twikooDisableImage = { bound: true };
      }

      // 覆盖 Twikoo 配置的 SHOW_IMAGE
      if (window.twikoo && window.twikoo.config) {
        window.twikoo.config.SHOW_IMAGE = 'false';
      }

      // 隐藏并禁用可能的上传按钮 / 图标 / 文件输入
      const selectors = [
        'input[type="file"]',
        '.tk-upload',
        '.tk-upload-btn',
        '.tk-open-image',
        '.tk-image',
        '.tk-image-picker',
        '.tk-img',
        '.tk-action-icon[title*="图"]',
        '.tk-action-icon[title*="图片"]',
        '[title*="图"]',
        '[title*="图片"]',
        '[aria-label*="图"]',
        '[aria-label*="图片"]',
        '.fa-image',
        '.tk-input-image'
      ];

      function removeOrHide(el) {
        if (!el) return;
        if (el.tagName && el.tagName.toLowerCase() === 'input' && el.type === 'file') {
          el.disabled = true;
          try {
            el.remove();
          } catch (e) {
            el.style.display = 'none';
          }
        } else {
          el.style.display = 'none';
          el.setAttribute('aria-hidden', 'true');
        }
      }

      // 初次清理现有元素
      selectors.forEach(sel => {
        document.querySelectorAll('#tcomment ' + sel).forEach(removeOrHide);
        // 也检查全局（如 OwO 插件可能在 body 下）
        document.querySelectorAll(sel).forEach(removeOrHide);
      });

      // 额外：直接移除明显的“图片上传”图标（匹配 SVG 路径片段），以及其相邻的 file input
      document.querySelectorAll('#tcomment .tk-submit-action-icon, .tk-submit-action-icon').forEach(el => {
        try {
          const svg = el.querySelector && el.querySelector('svg');
          const svgHtml = svg && svg.outerHTML;
          if (svgHtml && svgHtml.indexOf('M464 64H48') !== -1) {
            // 这是目标上传图标，直接移除
            const parent = el.parentElement;
            el.remove();
            // 如果其后有文件输入也移除
            if (parent) {
              parent.querySelectorAll && parent.querySelectorAll('input[type="file"]').forEach(fi => fi.remove());
            }
          }
        } catch (e) {
          // ignore
        }
      });

      // 阻止粘贴事件中包含文件（图片）的默认上传行为
      const pasteHandler = (e) => {
        try {
          const items = (e.clipboardData && e.clipboardData.items) || [];
          for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item && item.kind === 'file') {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }
          }
        } catch (err) {
          // ignore
        }
      };

      // 阻止点击打开文件选择或上传的行为（优先捕获）
      const clickHandler = (e) => {
        try {
          const target = e.target;
          if (!target) return;
          // If the click happens inside OwO (emoji picker), allow it so OwO can handle its UI
          if (target.closest && (target.closest('.OwO') || target.closest('.tk-owo'))) {
            return;
          }
          // 检查目标或其祖先是否匹配上传相关选择器（只阻止非 OwO 内的上传触发）
          if (target.closest && (
            target.closest('.tk-submit-action-icon') ||
            target.closest('.tk-open-image') ||
            target.closest('.tk-upload') ||
            target.closest('.tk-upload-btn') ||
            target.closest('.tk-input-image')
          )) {
            e.preventDefault();
            e.stopImmediatePropagation();
            return false;
          }
        } catch (err) {
          // ignore
        }
      };

      // 阻止文件输入的 change 事件（防止通过脚本触发上传）
      const changeHandler = (e) => {
        try {
          const t = e.target;
          if (t && t.tagName && t.tagName.toLowerCase() === 'input' && t.type === 'file') {
            e.preventDefault();
            e.stopImmediatePropagation();
            t.value = '';
            // 可选：显示临时提示，避免用户误以为上传成功
            if (t.closest) {
              const container = t.closest('.tk-row');
              if (container) {
                const errEl = container.querySelector('.tk-error-message');
                if (errEl) {
                  errEl.textContent = '图片上传已被管理员禁用';
                }
              }
            }
            return false;
          }
        } catch (err) {
          // ignore
        }
      };

      // MutationObserver：监控新增节点并移除/隐藏上传控件
      const commentEl = document.getElementById('tcomment');
      const observerCallback = (mutationsList) => {
        for (const mutation of mutationsList) {
          if (mutation.type === 'childList' && mutation.addedNodes.length) {
            mutation.addedNodes.forEach(node => {
              if (node.nodeType !== 1) return;
              selectors.forEach(sel => {
                node.querySelectorAll && node.querySelectorAll(sel).forEach(removeOrHide);
                // 如果新增节点本身就是上传控件，也处理
                if (node.matches && node.matches(sel)) removeOrHide(node);
              });

              // 额外检查新增节点中是否包含目标上传图标（匹配 SVG 路径），若有直接移除
              try {
                const icons = (node.querySelectorAll && node.querySelectorAll('.tk-submit-action-icon')) || [];
                icons.forEach(ic => {
                  const svg = ic.querySelector && ic.querySelector('svg');
                  if (svg && svg.outerHTML && svg.outerHTML.indexOf('M464 64H48') !== -1) {
                    const parent = ic.parentElement;
                    ic.remove();
                    if (parent) parent.querySelectorAll && parent.querySelectorAll('input[type="file"]').forEach(fi => fi.remove());
                  }
                });
                // 如果新增节点本身就是该图标
                if (node.matches && node.matches('.tk-submit-action-icon')) {
                  const svg = node.querySelector && node.querySelector('svg');
                  if (svg && svg.outerHTML && svg.outerHTML.indexOf('M464 64H48') !== -1) {
                    node.remove();
                  }
                }
              } catch (e) {
                // ignore
              }

              // 处理新增的评论内图片：延迟加载、Async 解码、最大宽度约束
              try {
                (node.querySelectorAll && node.querySelectorAll('img')) && node.querySelectorAll('img').forEach(img => {
                  try {
                    img.loading = 'lazy';
                    img.decoding = 'async';
                    img.style.maxWidth = '100%';
                    img.style.height = 'auto';
                    // Add a helper class for consistent object-fit handling
                    img.classList.add('tk-img-processed');
                  } catch (e) { /* ignore per-image errors */ }
                });
              } catch (e) { /* ignore */ }
            });
          }
        }
      };

      // 启动观察器并保存引用，避免重复创建多个观察器
      if (commentEl && !window.__twikooDisableImage.observer) {
        const mo = new MutationObserver(observerCallback);
        mo.observe(commentEl, { childList: true, subtree: true });
        window.__twikooDisableImage.observer = mo;
      }

      // 全局事件绑定（优先捕获），只绑定一次
      if (!window.__twikooDisableImage.boundClick) {
        document.addEventListener('click', clickHandler, true);
        document.addEventListener('change', changeHandler, true);
        document.addEventListener('paste', pasteHandler, true);
        window.__twikooDisableImage.boundClick = true;
      }

    } catch (err) {
      console.warn('[Twikoo] 禁用图片控件失败：', err);
    }
  }

  // 初始化 Twikoo
  function initTwikoo() {
    if (typeof twikoo !== 'undefined') {
      const commentEl = document.getElementById('tcomment');
      if (commentEl) {
        commentEl.innerHTML = '';

        const dynamicConfig = createTwikooConfig();
        console.log('[Twikoo] 初始化配置:', dynamicConfig);

        // 先在本地防御一层，确保在 twikoo 初始化前没有文件输入或按钮
        disableImageControls();

        twikoo.init(dynamicConfig).then(() => {
          try {
            console.log('[Twikoo] 初始化完成');
            // 初始化完成后再次清理（防止库或远程配置重新插入控件）
            disableImageControls();
            // ensure comment images have lazy loading and constrained sizing
            sanitizeCommentImages();
              // Re-enable pointer events on possible OwO containers and make sure they are above overlays
              const owoSelectors = ['#tcomment .OwO', '#tcomment .tk-owo', '#tcomment .OwO-body', '#tcomment .OwO-items', '#tcomment .OwO-item'];
              owoSelectors.forEach(sel => {
                document.querySelectorAll(sel).forEach(el => {
                  el.style.pointerEvents = 'auto';
                  el.style.zIndex = 99999;
                });
              });

              // Add capturing pointerdown logger to see what element receives the interaction
              function pointerLogger(e) {
                try {
                  const el = document.elementFromPoint(e.clientX, e.clientY);
                  if (!el) return;
                  if (el.closest && (el.closest('.OwO') || el.closest('.tk-owo') || el.closest('.OwO-item') || el.closest('.OwO-items'))) {
                    console.log('[Twikoo Debug] pointerdown at OwO element:', el);
                  } else {
                    // Log topmost element at click for diagnosis when OwO not responding
                    console.log('[Twikoo Debug] pointerdown top element:', el);
                  }
                } catch (err) { console.warn('[Twikoo Debug] pointerLogger error', err); }
              }

              document.removeEventListener('pointerdown', window.__twikooPointerLogger, true);
              window.__twikooPointerLogger = pointerLogger;
              document.addEventListener('pointerdown', pointerLogger, true);

              // Add pointerup/mouseup logger to see full interaction sequence
              function pointerUpLogger(e) {
                try {
                  const el = document.elementFromPoint(e.clientX, e.clientY);
                  if (!el) return;
                  if (el.closest && (el.closest('.OwO') || el.closest('.tk-owo') || el.closest('.OwO-item') || el.closest('.OwO-items'))) {
                    console.log('[Twikoo Debug] pointerup at OwO element:', el);
                  } else {
                    console.log('[Twikoo Debug] pointerup top element:', el);
                  }
                } catch (err) { console.warn('[Twikoo Debug] pointerUpLogger error', err); }
              }
              document.removeEventListener('pointerup', window.__twikooPointerUpLogger, true);
              window.__twikooPointerUpLogger = pointerUpLogger;
              document.addEventListener('pointerup', pointerUpLogger, true);

              // Add click logger on capture phase as well, to detect if events are blocked later
              function clickLogger(e) {
                try {
                  const t = e.target;
                  if (t && (t.closest('.tk-owo') || t.closest('.OwO') || t.closest('.OwO-item') || t.closest('.OwO-items') || t.closest('.OwO-logo'))) {
                    console.log('[Twikoo Debug] click detected on OwO item', t);
                  }
                } catch (err) { /* ignore */ }
              }
              document.removeEventListener('click', window.__twikooClickLogger, true);
              window.__twikooClickLogger = clickLogger;
              document.addEventListener('click', clickLogger, true);

              // Attach a capture-phase click handler to OwO logos to perform an atomic toggle
              // (open/close the OwO container AND show/hide the items together) to avoid race
              // conditions with the library's native click handler which may cause a flash.
              document.querySelectorAll('#tcomment .OwO, #tcomment .tk-owo').forEach(root => {
                try {
                  const logo = root.querySelector('.OwO-logo');
                  if (!logo) return;
                  if (logo.__twikooLogoHandler) logo.removeEventListener('click', logo.__twikooLogoHandler, true);
                  logo.__twikooLogoHandler = function (ev) {
                    try {
                      ev.stopImmediatePropagation();
                      ev.preventDefault();

                      const items = Array.from(root.querySelectorAll('.OwO-items'));
                      if (!items || items.length === 0) return;

                      const anyShown = items.some(it => it.classList.contains('OwO-items-show'));

                      if (anyShown || root.classList.contains('OwO-open')) {
                        // currently shown -> hide both items and container
                        items.forEach(it => it.classList.remove('OwO-items-show'));
                        root.classList.remove('OwO-open');
                        const activePkg = root.querySelectorAll('.OwO-package-active') || [];
                        activePkg.forEach(p => p.classList.remove('OwO-package-active'));
                        console.log('[Twikoo Debug] logo toggle: hiding OwO');
                        return;
                      }

                      // currently hidden -> show active package (or first) and open container
                      const activeIdx = Array.from(root.querySelectorAll('.OwO-packages li')).findIndex(li => li.classList.contains('OwO-package-active'));
                      if (root.__twikooShowPackage) root.__twikooShowPackage(activeIdx === -1 ? 0 : activeIdx);
                      else items[0].classList.add('OwO-items-show');
                      root.classList.add('OwO-open');
                      console.log('[Twikoo Debug] logo toggle: showing OwO');
                    } catch (err) { console.warn('[Twikoo Debug] logo handler failed', err); }
                  };
                  logo.addEventListener('click', logo.__twikooLogoHandler, true);
                } catch (err) { /* ignore per-root errors */ }
              });

              // Ensure package buttons control which OwO-items list is visible (only one at a time)
              function setupOwOPackages(owoRoot) {
                try {
                  const pkgList = owoRoot.querySelector('.OwO-packages');
                  const items = Array.from(owoRoot.querySelectorAll('.OwO-items'));
                  if (!pkgList || items.length === 0) return;
                  const pkgs = Array.from(pkgList.querySelectorAll('li'));

                  // default active index: any with show, else -1 (none)
                  let activeIndex = items.findIndex(it => it.classList.contains('OwO-items-show'));
                  if (activeIndex === -1) activeIndex = -1;

                  // body: hide initially if nothing is shown, keep .OwO-open in sync
                  const body = owoRoot.querySelector('.OwO-body');
                  const hasShown = items.some(it => it.classList.contains('OwO-items-show'));
                  if (body) {
                    if (hasShown) {
                      body.style.display = '';
                      owoRoot.classList.add('OwO-open');
                    } else {
                      body.style.display = 'none';
                      owoRoot.classList.remove('OwO-open');
                    }
                  }

                  // enforce single visible list (if any)
                  items.forEach((it, i) => {
                    if (i === activeIndex) it.classList.add('OwO-items-show'); else it.classList.remove('OwO-items-show');
                  });

                  // bind package buttons
                  pkgs.forEach((li, i) => {
                    // set active class
                    li.classList.toggle('OwO-package-active', i === activeIndex);

                    // remove previous handler if any
                    if (li.__twikooPkgHandler) li.removeEventListener('click', li.__twikooPkgHandler);
                    li.__twikooPkgHandler = function (ev) {
                      try {
                        // On first click, ensure body is visible and OwO is open
                        if (body && body.style.display === 'none') {
                          body.style.display = '';
                        }

                        items.forEach((it, j) => {
                          if (j === i) it.classList.add('OwO-items-show'); else it.classList.remove('OwO-items-show');
                        });
                        pkgs.forEach((p, idx) => p.classList.toggle('OwO-package-active', idx === i));

                        // Ensure OwO container is opened so bar/items are visible
                        owoRoot.classList.add('OwO-open');

                        console.log('[Twikoo Debug] OwO package selected:', i);
                      } catch (err) { console.warn('[Twikoo Debug] package handler failed', err); }
                    };
                    li.addEventListener('click', li.__twikooPkgHandler);
                  });

                  // expose helper to show package programmatically
                  owoRoot.__twikooShowPackage = (index) => {
                    if (body) body.style.display = '';
                    // Ensure OwO container is opened when showing a package programmatically
                    owoRoot.classList.add('OwO-open');
                    items.forEach((it, j) => {
                      if (j === index) it.classList.add('OwO-items-show'); else it.classList.remove('OwO-items-show');
                    });
                    pkgs.forEach((p, idx) => p.classList.toggle('OwO-package-active', idx === index));
                  };
                } catch (err) { console.warn('[Twikoo Debug] setupOwOPackages failed', err); }
              }

              // Initialize setup for any OwO instances in the comment area
              try {
                document.querySelectorAll('#tcomment .OwO, #tcomment .tk-owo').forEach(root => setupOwOPackages(root));
              } catch (err) { /* ignore */ }

              // If OwO exists but interaction doesn't work, try to force-init OwO emotions if Twikoo exposes the API
              if (window.twikoo && window.twikoo.initOwo && typeof window.twikoo.initOwo === 'function') {
                try {
                  window.twikoo.initOwo();
                  console.log('[Twikoo Debug] called twikoo.initOwo() to ensure emotions loaded');
                } catch (e) { console.warn('[Twikoo Debug] twikoo.initOwo() failed', e); }
              }

            } catch (err) {
              console.warn('[Twikoo Debug] setup failed', err);
            }
        }).catch((error) => {
          console.error('[Twikoo] 初始化失败:', error);
          // 失败时也执行清理，避免残留控件
          disableImageControls();
        });
      }
    } else {
      // 如果 Twikoo 未加载，稍后重试
      setTimeout(initTwikoo, 500);
    }
  }

  // 页面加载时初始化
  document.addEventListener('DOMContentLoaded', initTwikoo);

  // Swup 页面切换后重新初始化
  if (window.swup && window.swup.hooks) {
    window.swup.hooks.on('content:replace', function() {
      setTimeout(() => { initTwikoo(); disableImageControls(); }, 200);
    });
  } else {
    document.addEventListener('swup:enable', function() {
      if (window.swup && window.swup.hooks) {
        window.swup.hooks.on('content:replace', function() {
          setTimeout(() => { initTwikoo(); disableImageControls(); }, 200);
        });
      }
    });
  }

  // 自定义事件监听
  document.addEventListener('mizuki:page:loaded', function() {
    const commentEl = document.getElementById('tcomment');
    if (commentEl) {
      console.log('[Twikoo] 通过自定义事件重新初始化');
      initTwikoo();
      disableImageControls();
    }
  });
</script>