---
// 加载画面组件 - 在页面加载完成后自动隐藏
import { siteConfig } from "../config";
const configHue = siteConfig.themeColor.hue;
---

<div id="loading-screen" class="fixed inset-0 z-[9999] flex items-center justify-center bg-white dark:bg-neutral-950 transition-opacity duration-500">
	<!-- 加载动画容器 -->
	<div class="flex flex-col items-center gap-8">
		<!-- 旋转加载圆 -->
		<div class="relative w-16 h-16">
			<div class="absolute inset-0 rounded-full border-4 border-neutral-200 dark:border-neutral-800"></div>
			<div class="absolute inset-0 rounded-full border-4 border-transparent border-t-[var(--primary)] border-r-[var(--primary)] animate-spin"></div>
		</div>

		<!-- 加载文本与进度百分比 -->
		<div class="flex flex-col items-center gap-1">
			<p class="text-lg font-semibold text-neutral-900 dark:text-neutral-100">加载中...</p>
			<p class="text-sm text-neutral-500 dark:text-neutral-500">正在准备精彩内容</p>
			<p id="loading-percent" class="text-xs text-neutral-500 dark:text-neutral-400">0%</p>
		</div>

		<!-- 进度条 -->
		<div class="w-56 h-2 bg-neutral-200 dark:bg-neutral-800 rounded-full overflow-hidden shadow-inner">
			<div id="loading-progress" class="h-full rounded-full transition-[width] duration-300 ease-out" style="width:0%"></div>
		</div>
	</div>
</div>

<style>
	@keyframes gradientMove {
		0% { background-position: 0% 50%; }
		100% { background-position: 200% 50%; }
	}

	@keyframes shimmer {
		0% {
			transform: translateX(-100%);
		}
		100% {
			transform: translateX(100%);
		}
	}

	#loading-progress {
		background: linear-gradient(
			90deg,
			color-mix(in oklch, var(--primary) 88%, white 12%),
			color-mix(in oklch, var(--primary) 78%, white 22%),
			color-mix(in oklch, var(--primary) 88%, white 12%)
		);
		background-size: 200% 100%;
		animation: gradientMove 2s linear infinite;
		position: relative;
		overflow: hidden;
		box-shadow: 
			0 0 10px color-mix(in oklch, var(--primary) 70%, transparent),
			0 0 20px color-mix(in oklch, var(--primary) 50%, transparent),
			inset 0 1px 0 color-mix(in oklch, var(--primary) 60%, white 40%);
	}

	#loading-progress::after {
		content: '';
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		background: linear-gradient(
			90deg,
			transparent,
			rgba(255, 255, 255, 0.4),
			transparent
		);
		animation: shimmer 1.5s ease-in-out infinite;
	}

	@keyframes fadeOut {
		to {
			opacity: 0;
			visibility: hidden;
		}
	}

	#loading-screen.hide {
		animation: fadeOut 0.5s ease-out forwards;
	}
</style>

<script is:inline define:vars={{ configHue }}>
	// 在最早阶段设置主题色变量
	const savedHue = localStorage.getItem('hue') || configHue;
	document.documentElement.style.setProperty('--hue', savedHue);
	
	// 防止 FOUC（Flash of Unstyled Content）
	const prevHtmlOverflow = document.documentElement.style.overflow;
	const prevBodyOverflow = document.body ? document.body.style.overflow : '';
	document.documentElement.style.overflow = 'hidden';
	if (document.body) document.body.style.overflow = 'hidden';
	
	// 模拟加载进度（更平滑的曲线）
	const progressBar = document.getElementById('loading-progress');
	const percentText = document.getElementById('loading-percent');
	
	let progress = 20;
	let lastUpdateTime = Date.now();
	let loadingStartTime = Date.now();

	const updateProgress = () => {
		const elapsed = Date.now() - loadingStartTime;
		const maxWait = 5000; // 最多等待5秒（减少等待时间）

		if (progress < 50) {
			// 前期快速增长 (20% -> 50%)
			progress += Math.random() * 20 + 10;
		} else if (progress < 80) {
			// 中期逐渐变慢 (50% -> 80%)
			progress += Math.random() * 12 + 5;
		} else {
			// 后期非常慢 (80% -> 95%)
			progress += Math.random() * 3 + 1;
		}

		// 防止溢出
		progress = Math.min(progress, 95);

		if (progressBar) {
			progressBar.style.width = Math.min(progress, 98) + '%';
		}
		if (percentText) {
			percentText.textContent = `${Math.round(progress)}%`;
		}

		// 如果加载超时，加快进度
		if (elapsed > maxWait && progress < 90) {
			progress = 90;
		}

		// 继续更新直到页面加载完成
		if (progress < 95) {
			lastUpdateTime = Date.now();
			setTimeout(updateProgress, 100 + Math.random() * 200); // 更新更频繁
		}
	};

	updateProgress();

	function restoreScroll() {
		// 恢复滚动（双保险：同时恢复 html 和 body）
		document.documentElement.style.overflow = prevHtmlOverflow || '';
		if (document.body) document.body.style.overflow = prevBodyOverflow || '';
	}

	function removeLoadingScreen() {
		const loadingScreen = document.getElementById('loading-screen');
		if (loadingScreen) {
			loadingScreen.classList.add('hide');
			setTimeout(() => {
				loadingScreen.remove();
				restoreScroll();
			}, 500);
		} else {
			restoreScroll();
		}
	}

	// 监听页面加载完成
	window.addEventListener('load', () => {
		// 完成进度条
		if (progressBar) {
			progressBar.style.width = '100%';
		}

		// 延迟一下以确保所有资源都加载完成
		setTimeout(removeLoadingScreen, 200);
	});

	// 确保 DOM 交互性强时隐藏加载屏幕
	if (document.readyState === 'complete') {
		if (percentText) percentText.textContent = '100%';
		if (progressBar) progressBar.style.width = '100%';
		removeLoadingScreen();
	}

	// 与 Swup 集成：无论何时内容替换完成，都确保移除加载层并恢复滚动
	document.addEventListener('swup:contentReplaced', removeLoadingScreen, { once: true });
	document.addEventListener('swup:animationOutDone', restoreScroll);

	// 安全兜底：3 秒后强制恢复滚动（防止极端情况下事件未触发）
	setTimeout(restoreScroll, 3000);
</script>
